<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吴晓龙</title>
  <icon>https://www.gravatar.com/avatar/c3164500aaa6ba4b06d2c5617067c85e</icon>
  <subtitle>爱吃哈密瓜的程序员</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-09T11:02:58.094Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>吴晓龙</name>
    <email>635912159@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>setCompoundDrawables不显示图片</title>
    <link href="http://yoursite.com/2018/01/09/setCompoundDrawables%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2018/01/09/setCompoundDrawables不显示图片/</id>
    <published>2018-01-09T10:59:47.000Z</published>
    <updated>2018-01-09T11:02:58.094Z</updated>
    
    <content type="html"><![CDATA[<h3 id="BUG-28475-海外版登陆界面缺少Hi图标中代码不起作用的问题"><a href="#BUG-28475-海外版登陆界面缺少Hi图标中代码不起作用的问题" class="headerlink" title="BUG #28475 海外版登陆界面缺少Hi图标中代码不起作用的问题"></a><strong>BUG #28475 海外版登陆界面缺少Hi图标中代码不起作用的问题</strong></h3><h2 id="dynamicAddView会调用BaseActivity的dynamicAddSkinEnableView，"><a href="#dynamicAddView会调用BaseActivity的dynamicAddSkinEnableView，" class="headerlink" title="dynamicAddView会调用BaseActivity的dynamicAddSkinEnableView，"></a>dynamicAddView会调用BaseActivity的dynamicAddSkinEnableView，</h2><h2 id="然后调用AttrFactory-get，通过if-else判断"><a href="#然后调用AttrFactory-get，通过if-else判断" class="headerlink" title="然后调用AttrFactory.get，通过if else判断"></a>然后调用AttrFactory.get，通过if else判断</h2><p>mSkinAttr = new DrawableLeftAttr();</p><p>看代码知道最终调用setCompoundDrawables。通过debug发现已进入equas方法，</p><p>但最终并未成功加载图片到textView的左侧。</p><p>然后去看setCompoundDrawables源码，发现有这么一句注释。</p><p>```Sets the Drawables (if any) to appear to the left of, above, to the</p><ul><li>right of, and below the text. Use {@code null} if you do not want a</li><li>Drawable there. The Drawables must already have had</li><li>{@link Drawable#setBounds} called.</li></ul><p>skin.lib不能修改源码，只能写demo来验证是不是这个原因造成的。</p><p>布局这样子，能正常显示，运行起来也没有问题。</p><p>然后代码里修改，通过setCompoundDrawables在Textview左侧加图片，运行发现不能正常显示。</p><p>调用drawable.setBounds 后能够正常显示。</p><p>2、直接调用setCompoundDrawablesWithIntrinsicBounds方法，不用setBounds也能正常显示。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;BUG-28475-海外版登陆界面缺少Hi图标中代码不起作用的问题&quot;&gt;&lt;a href=&quot;#BUG-28475-海外版登陆界面缺少Hi图标中代码不起作用的问题&quot; class=&quot;headerlink&quot; title=&quot;BUG #28475 海外版登陆界面缺少Hi图标中代
      
    
    </summary>
    
    
      <category term="android bug" scheme="http://yoursite.com/tags/android-bug/"/>
    
  </entry>
  
  <entry>
    <title>startService引起的FC</title>
    <link href="http://yoursite.com/2018/01/07/startService%E5%BC%95%E8%B5%B7%E7%9A%84FC/"/>
    <id>http://yoursite.com/2018/01/07/startService引起的FC/</id>
    <published>2018-01-06T16:25:20.000Z</published>
    <updated>2018-01-08T11:14:41.837Z</updated>
    
    <content type="html"><![CDATA[<h3 id="bug描述"><a href="#bug描述" class="headerlink" title="bug描述"></a>bug描述</h3><p>Short Msg: java.lang.RuntimeException<br>// Long Msg: java.lang.RuntimeException: Unknown exception code: 1936206469 msg null<br>// Build Label: OPPO/R9PlusmA/R9PlusA:6.0.1/MMB29M/1481606711:user/release-keys<br>// Build Changelist: eng.root.20171024.134100<br>// Build Time: 1508823947000<br>// java.lang.RuntimeException: Unable to create service com.kingsoft.email.eventbus.Transferservice: java.lang.RuntimeException: Unknown exception code: 1936206469 msg null<br>//     at android.app.ActivityThread.handleCreateService(ActivityThread.java:2978)<br>//     at android.app.ActivityThread.access$2100(ActivityThread.java:165)<br>//     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1513)<br>//     at android.os.Handler.dispatchMessage(Handler.java:102)<br>//     at android.os.Looper.loop(Looper.java:179)<br>//     at android.app.ActivityThread.main(ActivityThread.java:5672)<br>//     at java.lang.reflect.Method.invoke(Native Method)<br>//     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:786)<br>//     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:676)<br>// Caused by: java.lang.RuntimeException: Unknown exception code: 1936206469 msg null<br>//     at android.os.Parcel.readException(Parcel.java:1644)<br>//     at android.os.Parcel.readException(Parcel.java:1583)<br>//     at android.app.ActivityManagerProxy.serviceDoneExecuting(ActivityManagerNative.java:3907)<br>//     at android.app.ActivityThread.handleCreateService(ActivityThread.java:2971)<br>//     … 8 more</p><h3 id="onStartCommand方法返回的数值问题"><a href="#onStartCommand方法返回的数值问题" class="headerlink" title="onStartCommand方法返回的数值问题"></a>onStartCommand方法返回的数值问题</h3><p><strong>这里主要解释这三个变量的意义：</strong></p><p><em>1、  START_STICKY</em></p><p>在运行onStartCommand后service进程被kill后，那将保留在开始状态，但是不保留那些传入的intent。不久后service就会再次尝试重新创建，因为保留在开始状态，在创建     service后将保证调用onstartCommand。如果没有传递任何开始命令给service，那将获取到null的intent</p><p><em>2、  START_STICKY</em></p><p>在运行onStartCommand后service进程被kill后，并且没有新的intent传递给它。Service将移出开始状态，并且直到新的明显的方法（startService）调用才重新创建。因为如果没有传递任何未决定的intent那么service是不会启动，也就是期间onstartCommand不会接收到任何null的intent。</p><p><em>3、  START_REDELIVER_INTENT</em></p><p>在运行onStartCommand后service进程被kill后，系统将会再次启动service，并传入最后一个intent给onstartCommand。直到调用stopSelf(int)才停止传递intent。如果在被kill后还有未处理好的intent，那被kill后服务还是会自动启动。因此onstartCommand不会接收到任何null的intent。</p><blockquote><p>START_STICKY和 START_STICKY：当进程被杀死后onDestroy()是不会被执行的！</p><p>START_REDELIVER_INTENT ：当进程被杀死后onDestroy()会被执行！</p><hr><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a><a href="http://blog.csdn.net/ssstudio/article/details/7258363" target="_blank" rel="noopener">参考文章</a></h2></blockquote><h2 id="必应图"><a href="#必应图" class="headerlink" title="必应图"></a><a href="http://cn.bing.com/az/hprichbg/rb/Wintersolstice1222_ROW10807868228_1920x1080.jpg" target="_blank" rel="noopener">必应图</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;bug描述&quot;&gt;&lt;a href=&quot;#bug描述&quot; class=&quot;headerlink&quot; title=&quot;bug描述&quot;&gt;&lt;/a&gt;bug描述&lt;/h3&gt;&lt;p&gt;Short Msg: java.lang.RuntimeException&lt;br&gt;// Long Msg: java
      
    
    </summary>
    
    
      <category term="android bug" scheme="http://yoursite.com/tags/android-bug/"/>
    
  </entry>
  
  <entry>
    <title>这是我的第一篇博客</title>
    <link href="http://yoursite.com/2018/01/06/%E5%BF%83%E5%BE%97/"/>
    <id>http://yoursite.com/2018/01/06/心得/</id>
    <published>2018-01-06T14:53:35.000Z</published>
    <updated>2018-01-08T10:14:47.227Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><p>-改一款手机的bug应该考虑到一整个系列的手机类型。尤其是oem针对手机系统做适配，eg：全面屏手机顶部被遮盖，顶部挤压等应该向厂商咨询一整个系列的全面屏手机型号，而不是只针对一款手机做适配，解决问题要彻底，考虑问题要更全面。</p><hr><p>-对于可能引起的bug要足够重视，并且想清楚解决方案，改的不彻底不全面就会在某个时间点引起新的bug。如sendmail@mailtest.垃圾邮件同步异常是由于远程文件夹不存在，但privider没有这种异常，于是暂时性用了其他已用到的异常类型，直到其他问题引起这种异常从而出现莫名的显示效果。</p><hr><p>-项目涉及到国际版，所以改资源改jar包引用都要考虑到国际版。</p><hr><p>-改一个分支比如单飞的bug要考虑到oem4.3.2分支是不是也有同样的问题。</p><hr><p>-不要复制，数组这种直接复制过来不改下标就有可能导致越界而奔溃。</p><hr><p>-actionbar从未读到抽屉不正常显示bug带来的收益：首先找到点击的位置，比如从命名、图片等，然后debug跟踪，log打印最后定位到两者的区别，跟踪到是observer没有收到回调，再继续往下跟发现时loader没有调onloaderfinish方法，至于为什么没有调onloadfinish再继续往下跟发现是restartloader返回的不对，再继续往下跟踪就会发现这个掉了两次，debug发现了却没有引起足够的重视。最后解决是别的同学追踪他的bug发现的，同一个方法执行两次所以onstarloader调用两次，在低版本的手机上就会有问题。这个问题到这里没有继续往下跟，应该还能找到系统底层的区别，比如源码，但这个带给我们的教训是，重复执行一个方法多次会有不同的结果，特别是在不同版本的手机，源码不断被修改。</p><hr><p>-修改一处空指针要想到是否还有其他地方因为这个空指针造成的问题。如permission denied，string类型的返回值需要判空</p><hr><p>-改动一个bug要尽可能小的影响到其他情况。</p><hr><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;hr&gt;
&lt;p&gt;-改一款手机的bug应该考虑到一整个系列的手机类型。尤其是oem针对手机系统做适配，eg：全面屏手机顶部被遮盖，顶部挤压等应该向厂商咨询一整个系列的全面屏手机型号，而不是只针对一款手机做适配，解决问题要彻底，考虑问题要更全面。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;-
      
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="random" scheme="http://yoursite.com/tags/random/"/>
    
  </entry>
  
</feed>
