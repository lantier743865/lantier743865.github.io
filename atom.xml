<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吴晓龙</title>
  <icon>https://www.gravatar.com/avatar/c3164500aaa6ba4b06d2c5617067c85e</icon>
  <subtitle>爱吃哈密瓜的程序员</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-12T06:09:28.866Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>吴晓龙</name>
    <email>635912159@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 项目构建过程</title>
    <link href="http://yoursite.com/2018/01/12/Android-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/01/12/Android-项目构建过程/</id>
    <published>2018-01-12T06:04:05.000Z</published>
    <updated>2018-01-12T06:09:28.866Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-1、AAPT（Android-Asset-Packaging-Tool）工具会打包应用中的资源文件，如AndroidManifest-xml、layout布局中的xml等，并将xml文件编译为二进制形式，当然asset文件夹中的文件不会被编译，图片几raw文件夹中的资源也会保持原来的形态，需要注意的是raw文件夹种的资源也会生成资源id。AAPT编译完成后会生成R-java文件。"><a href="#1-1、AAPT（Android-Asset-Packaging-Tool）工具会打包应用中的资源文件，如AndroidManifest-xml、layout布局中的xml等，并将xml文件编译为二进制形式，当然asset文件夹中的文件不会被编译，图片几raw文件夹中的资源也会保持原来的形态，需要注意的是raw文件夹种的资源也会生成资源id。AAPT编译完成后会生成R-java文件。" class="headerlink" title="1. 1、AAPT（Android Asset Packaging Tool）工具会打包应用中的资源文件，如AndroidManifest.xml、layout布局中的xml等，并将xml文件编译为二进制形式，当然asset文件夹中的文件不会被编译，图片几raw文件夹中的资源也会保持原来的形态，需要注意的是raw文件夹种的资源也会生成资源id。AAPT编译完成后会生成R.java文件。"></a>1. 1、AAPT（Android Asset Packaging Tool）工具会打包应用中的资源文件，如AndroidManifest.xml、layout布局中的xml等，并将xml文件编译为二进制形式，当然asset文件夹中的文件不会被编译，图片几raw文件夹中的资源也会保持原来的形态，需要注意的是raw文件夹种的资源也会生成资源id。AAPT编译完成后会生成R.java文件。</h3><h3 id="2-2、AIDL工具会将所有的AIDL接口转化为java接口。"><a href="#2-2、AIDL工具会将所有的AIDL接口转化为java接口。" class="headerlink" title="2. 2、AIDL工具会将所有的AIDL接口转化为java接口。"></a>2. 2、AIDL工具会将所有的AIDL接口转化为java接口。</h3><h3 id="3-3、所有的java代码，包括R-java与aidl文件都会被java编译器编译成-class文件。"><a href="#3-3、所有的java代码，包括R-java与aidl文件都会被java编译器编译成-class文件。" class="headerlink" title="3. 3、所有的java代码，包括R.java与aidl文件都会被java编译器编译成.class文件。"></a>3. 3、所有的java代码，包括R.java与aidl文件都会被java编译器编译成.class文件。</h3><h3 id="4-4、Dex工具会将上述产生的-class文件及第三方库及其他-class文件编译成-dex文件（dex文件是Dalvik虚拟机可以执行的格式），dex文件最终会被打包进APK文件。"><a href="#4-4、Dex工具会将上述产生的-class文件及第三方库及其他-class文件编译成-dex文件（dex文件是Dalvik虚拟机可以执行的格式），dex文件最终会被打包进APK文件。" class="headerlink" title="4. 4、Dex工具会将上述产生的.class文件及第三方库及其他.class文件编译成.dex文件（dex文件是Dalvik虚拟机可以执行的格式），dex文件最终会被打包进APK文件。"></a>4. 4、Dex工具会将上述产生的.class文件及第三方库及其他.class文件编译成.dex文件（dex文件是Dalvik虚拟机可以执行的格式），dex文件最终会被打包进APK文件。</h3><h3 id="5-5、ApkBuilder工具会将编译过的资源（如图片等）以及-dex文件打包成APK文件。"><a href="#5-5、ApkBuilder工具会将编译过的资源（如图片等）以及-dex文件打包成APK文件。" class="headerlink" title="5. 5、ApkBuilder工具会将编译过的资源（如图片等）以及.dex文件打包成APK文件。"></a>5. 5、ApkBuilder工具会将编译过的资源（如图片等）以及.dex文件打包成APK文件。</h3><h3 id="6-6、生成apk文件后，需要对其签名才可安装到设备，平时测试会使用debug-keystore，当正式发布应用时必须使用release版的keysore对应用进行签名。"><a href="#6-6、生成apk文件后，需要对其签名才可安装到设备，平时测试会使用debug-keystore，当正式发布应用时必须使用release版的keysore对应用进行签名。" class="headerlink" title="6. 6、生成apk文件后，需要对其签名才可安装到设备，平时测试会使用debug keystore，当正式发布应用时必须使用release版的keysore对应用进行签名。"></a>6. 6、生成apk文件后，需要对其签名才可安装到设备，平时测试会使用debug keystore，当正式发布应用时必须使用release版的keysore对应用进行签名。</h3><h3 id="7-7、如果对APK正式签名，还需要使用zipalign工具对APK进行对齐操作，这样做的好处是当应用运行时会提高速度，但是相应会增加内存的开销。"><a href="#7-7、如果对APK正式签名，还需要使用zipalign工具对APK进行对齐操作，这样做的好处是当应用运行时会提高速度，但是相应会增加内存的开销。" class="headerlink" title="7. 7、如果对APK正式签名，还需要使用zipalign工具对APK进行对齐操作，这样做的好处是当应用运行时会提高速度，但是相应会增加内存的开销。"></a>7. 7、如果对APK正式签名，还需要使用zipalign工具对APK进行对齐操作，这样做的好处是当应用运行时会提高速度，但是相应会增加内存的开销。</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-1、AAPT（Android-Asset-Packaging-Tool）工具会打包应用中的资源文件，如AndroidManifest-xml、layout布局中的xml等，并将xml文件编译为二进制形式，当然asset文件夹中的文件不会被编译，图片几raw文件
      
    
    </summary>
    
      <category term="源码解析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>android 8.0同步问题适配相关问题（联想）</title>
    <link href="http://yoursite.com/2018/01/11/android-8-0%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%E9%80%82%E9%85%8D%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%EF%BC%88%E8%81%94%E6%83%B3%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/11/android-8-0同步问题适配相关问题（联想）/</id>
    <published>2018-01-11T07:19:23.000Z</published>
    <updated>2018-01-11T07:20:06.862Z</updated>
    
    <content type="html"><![CDATA[<h4 id="android-8-0同步问题适配相关问题（联想）"><a href="#android-8-0同步问题适配相关问题（联想）" class="headerlink" title="android 8.0同步问题适配相关问题（联想）"></a>android 8.0同步问题适配相关问题（联想）</h4><p>由于访问<a href="http://clients3.google.com/generate_204失败，导致的WiFi和移动网络提示“已连接" target="_blank" rel="noopener">http://clients3.google.com/generate_204失败，导致的WiFi和移动网络提示“已连接</a> 但无法访问互联网”问题<br>，查看之前版本源码，网络验证并未作为条件记录在jobStatus中，从dump出来信息看是同步操作的条件不满足。</p><p>反向验证，关闭网络验证</p><h3 id="1、adb-shell-settings-put-global-captive-portal-detection-enabled-0"><a href="#1、adb-shell-settings-put-global-captive-portal-detection-enabled-0" class="headerlink" title="1、adb shell settings put global captive_portal_detection_enabled 0"></a>1、adb shell settings put global captive_portal_detection_enabled 0</h3><p>执行关闭这个命令后adb reboot网络上叉号消失，同步正常。</p><h3 id="2、打开vpn，访问谷歌正常，同步邮件正常。"><a href="#2、打开vpn，访问谷歌正常，同步邮件正常。" class="headerlink" title="2、打开vpn，访问谷歌正常，同步邮件正常。"></a>2、打开vpn，访问谷歌正常，同步邮件正常。</h3><p><img src="http://opq81riyh.bkt.clouddn.com/ConnectivityController" alt="源码"><br><img src="http://opq81riyh.bkt.clouddn.com/Undtaisfied" alt="源码"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;android-8-0同步问题适配相关问题（联想）&quot;&gt;&lt;a href=&quot;#android-8-0同步问题适配相关问题（联想）&quot; class=&quot;headerlink&quot; title=&quot;android 8.0同步问题适配相关问题（联想）&quot;&gt;&lt;/a&gt;android 8.0
      
    
    </summary>
    
      <category term="bug" scheme="http://yoursite.com/categories/bug/"/>
    
    
      <category term="bug" scheme="http://yoursite.com/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>IPC方式的优缺点和适用场景</title>
    <link href="http://yoursite.com/2018/01/11/IPC%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://yoursite.com/2018/01/11/IPC方式的优缺点和适用场景/</id>
    <published>2018-01-11T06:29:19.000Z</published>
    <updated>2018-01-11T06:31:04.386Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>名称</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>Bundle</td><td>简单易用</td><td>只能传输Bundle支持的数据类型</td><td>四大组件间的进程间通信</td></tr><tr><td>文件共享</td><td>简单易用</td><td>不适合高并发场景，并且无法做到进程间的即时通信</td><td>无并发访问情形，交换简单的数据实时性不高的场景</td></tr><tr><td>AIDL</td><td>功能强大，支持一对多并发通信，支持实时通信</td><td>使用稍复杂，需处理好线程同步</td><td>一对多通信且有RPC需求</td></tr><tr><td>Messenager</td><td>功能一般，支持一对多串行通信，支持实时通信</td><td>不能很好的处理高并发情形，不支持RPC，数据通过Message进行传输，因此只能传输Bundle支持的数据类型</td><td>低并发的一对多即时通信，无RPC需求，或者无需返回结果的RPC需求</td></tr><tr><td>ContentProvider</td><td>在数据源访问方面功能强大，支持一对多并发数据共享，可通过call方法扩展其他操作</td><td>可以理解为受约束的AIDL，主要提供数据源的CRUD操作</td><td>一对多的进程间的数据共享</td></tr><tr><td>Socket</td><td>功能强大，可以通过网络传输字节流，支持一对多并发实时通信</td><td>实现细节稍有点繁琐，不支持杂直接的RPC</td><td>网络数据交换</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;th&gt;适用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Bundle&lt;/td&gt;
&lt;td&gt;简单易用&lt;/td&gt;
&lt;td&gt;只能传输Bun
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>setCompoundDrawables不显示图片</title>
    <link href="http://yoursite.com/2018/01/09/setCompoundDrawables%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2018/01/09/setCompoundDrawables不显示图片/</id>
    <published>2018-01-09T10:59:47.000Z</published>
    <updated>2018-01-09T11:11:46.357Z</updated>
    
    <content type="html"><![CDATA[<h3 id="BUG-28475-海外版登陆界面缺少Hi图标中代码不起作用的问题"><a href="#BUG-28475-海外版登陆界面缺少Hi图标中代码不起作用的问题" class="headerlink" title="BUG #28475 海外版登陆界面缺少Hi图标中代码不起作用的问题"></a><strong>BUG #28475 海外版登陆界面缺少Hi图标中代码不起作用的问题</strong></h3><h2 id="dynamicAddView会调用BaseActivity的dynamicAddSkinEnableView，"><a href="#dynamicAddView会调用BaseActivity的dynamicAddSkinEnableView，" class="headerlink" title="dynamicAddView会调用BaseActivity的dynamicAddSkinEnableView，"></a>dynamicAddView会调用BaseActivity的dynamicAddSkinEnableView，</h2><h2 id="然后调用AttrFactory-get，通过if-else判断"><a href="#然后调用AttrFactory-get，通过if-else判断" class="headerlink" title="然后调用AttrFactory.get，通过if else判断"></a>然后调用AttrFactory.get，通过if else判断</h2><p>mSkinAttr = new DrawableLeftAttr();</p><p>看代码知道最终调用setCompoundDrawables。通过debug发现已进入equas方法，</p><p>但最终并未成功加载图片到textView的左侧。</p><p>然后去看setCompoundDrawables源码，发现有这么一句注释。</p><p>```Sets the Drawables (if any) to appear to the left of, above, to the</p><ul><li>right of, and below the text. Use {@code null} if you do not want a</li><li>Drawable there. The Drawables must already have had</li><li>{@link Drawable#setBounds} called.</li></ul><p>skin.lib不能修改源码，只能写demo来验证是不是这个原因造成的。</p><p>布局这样子，能正常显示，运行起来也没有问题。</p><p>然后代码里修改，通过setCompoundDrawables在Textview左侧加图片，运行发现不能正常显示。</p><p>调用drawable.setBounds 后能够正常显示。</p><p>2、直接调用setCompoundDrawablesWithIntrinsicBounds方法，不用setBounds也能正常显示。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;BUG-28475-海外版登陆界面缺少Hi图标中代码不起作用的问题&quot;&gt;&lt;a href=&quot;#BUG-28475-海外版登陆界面缺少Hi图标中代码不起作用的问题&quot; class=&quot;headerlink&quot; title=&quot;BUG #28475 海外版登陆界面缺少Hi图标中代
      
    
    </summary>
    
      <category term="bug" scheme="http://yoursite.com/categories/bug/"/>
    
    
      <category term="android bug" scheme="http://yoursite.com/tags/android-bug/"/>
    
  </entry>
  
  <entry>
    <title>startService引起的FC</title>
    <link href="http://yoursite.com/2018/01/07/startService%E5%BC%95%E8%B5%B7%E7%9A%84FC/"/>
    <id>http://yoursite.com/2018/01/07/startService引起的FC/</id>
    <published>2018-01-06T16:25:20.000Z</published>
    <updated>2018-01-09T11:12:31.476Z</updated>
    
    <content type="html"><![CDATA[<h3 id="bug描述"><a href="#bug描述" class="headerlink" title="bug描述"></a>bug描述</h3><p>Short Msg: java.lang.RuntimeException<br>// Long Msg: java.lang.RuntimeException: Unknown exception code: 1936206469 msg null<br>// Build Label: OPPO/R9PlusmA/R9PlusA:6.0.1/MMB29M/1481606711:user/release-keys<br>// Build Changelist: eng.root.20171024.134100<br>// Build Time: 1508823947000<br>// java.lang.RuntimeException: Unable to create service com.kingsoft.email.eventbus.Transferservice: java.lang.RuntimeException: Unknown exception code: 1936206469 msg null<br>//     at android.app.ActivityThread.handleCreateService(ActivityThread.java:2978)<br>//     at android.app.ActivityThread.access$2100(ActivityThread.java:165)<br>//     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1513)<br>//     at android.os.Handler.dispatchMessage(Handler.java:102)<br>//     at android.os.Looper.loop(Looper.java:179)<br>//     at android.app.ActivityThread.main(ActivityThread.java:5672)<br>//     at java.lang.reflect.Method.invoke(Native Method)<br>//     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:786)<br>//     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:676)<br>// Caused by: java.lang.RuntimeException: Unknown exception code: 1936206469 msg null<br>//     at android.os.Parcel.readException(Parcel.java:1644)<br>//     at android.os.Parcel.readException(Parcel.java:1583)<br>//     at android.app.ActivityManagerProxy.serviceDoneExecuting(ActivityManagerNative.java:3907)<br>//     at android.app.ActivityThread.handleCreateService(ActivityThread.java:2971)<br>//     … 8 more</p><h3 id="onStartCommand方法返回的数值问题"><a href="#onStartCommand方法返回的数值问题" class="headerlink" title="onStartCommand方法返回的数值问题"></a>onStartCommand方法返回的数值问题</h3><p><strong>这里主要解释这三个变量的意义：</strong></p><p><em>1、  START_STICKY</em></p><p>在运行onStartCommand后service进程被kill后，那将保留在开始状态，但是不保留那些传入的intent。不久后service就会再次尝试重新创建，因为保留在开始状态，在创建     service后将保证调用onstartCommand。如果没有传递任何开始命令给service，那将获取到null的intent</p><p><em>2、  START_STICKY</em></p><p>在运行onStartCommand后service进程被kill后，并且没有新的intent传递给它。Service将移出开始状态，并且直到新的明显的方法（startService）调用才重新创建。因为如果没有传递任何未决定的intent那么service是不会启动，也就是期间onstartCommand不会接收到任何null的intent。</p><p><em>3、  START_REDELIVER_INTENT</em></p><p>在运行onStartCommand后service进程被kill后，系统将会再次启动service，并传入最后一个intent给onstartCommand。直到调用stopSelf(int)才停止传递intent。如果在被kill后还有未处理好的intent，那被kill后服务还是会自动启动。因此onstartCommand不会接收到任何null的intent。</p><blockquote><p>START_STICKY和 START_STICKY：当进程被杀死后onDestroy()是不会被执行的！</p><p>START_REDELIVER_INTENT ：当进程被杀死后onDestroy()会被执行！</p><hr><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a><a href="http://blog.csdn.net/ssstudio/article/details/7258363" target="_blank" rel="noopener">参考文章</a></h2></blockquote><h2 id="必应图"><a href="#必应图" class="headerlink" title="必应图"></a><a href="http://cn.bing.com/az/hprichbg/rb/Wintersolstice1222_ROW10807868228_1920x1080.jpg" target="_blank" rel="noopener">必应图</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;bug描述&quot;&gt;&lt;a href=&quot;#bug描述&quot; class=&quot;headerlink&quot; title=&quot;bug描述&quot;&gt;&lt;/a&gt;bug描述&lt;/h3&gt;&lt;p&gt;Short Msg: java.lang.RuntimeException&lt;br&gt;// Long Msg: java
      
    
    </summary>
    
      <category term="bug" scheme="http://yoursite.com/categories/bug/"/>
    
    
      <category term="bug" scheme="http://yoursite.com/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>这是我的第一篇博客</title>
    <link href="http://yoursite.com/2018/01/06/%E5%BF%83%E5%BE%97/"/>
    <id>http://yoursite.com/2018/01/06/心得/</id>
    <published>2018-01-06T14:53:35.000Z</published>
    <updated>2018-01-09T11:12:48.333Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><p>-改一款手机的bug应该考虑到一整个系列的手机类型。尤其是oem针对手机系统做适配，eg：全面屏手机顶部被遮盖，顶部挤压等应该向厂商咨询一整个系列的全面屏手机型号，而不是只针对一款手机做适配，解决问题要彻底，考虑问题要更全面。</p><hr><p>-对于可能引起的bug要足够重视，并且想清楚解决方案，改的不彻底不全面就会在某个时间点引起新的bug。如sendmail@mailtest.垃圾邮件同步异常是由于远程文件夹不存在，但privider没有这种异常，于是暂时性用了其他已用到的异常类型，直到其他问题引起这种异常从而出现莫名的显示效果。</p><hr><p>-项目涉及到国际版，所以改资源改jar包引用都要考虑到国际版。</p><hr><p>-改一个分支比如单飞的bug要考虑到oem4.3.2分支是不是也有同样的问题。</p><hr><p>-不要复制，数组这种直接复制过来不改下标就有可能导致越界而奔溃。</p><hr><p>-actionbar从未读到抽屉不正常显示bug带来的收益：首先找到点击的位置，比如从命名、图片等，然后debug跟踪，log打印最后定位到两者的区别，跟踪到是observer没有收到回调，再继续往下跟发现时loader没有调onloaderfinish方法，至于为什么没有调onloadfinish再继续往下跟发现是restartloader返回的不对，再继续往下跟踪就会发现这个掉了两次，debug发现了却没有引起足够的重视。最后解决是别的同学追踪他的bug发现的，同一个方法执行两次所以onstarloader调用两次，在低版本的手机上就会有问题。这个问题到这里没有继续往下跟，应该还能找到系统底层的区别，比如源码，但这个带给我们的教训是，重复执行一个方法多次会有不同的结果，特别是在不同版本的手机，源码不断被修改。</p><hr><p>-修改一处空指针要想到是否还有其他地方因为这个空指针造成的问题。如permission denied，string类型的返回值需要判空</p><hr><p>-改动一个bug要尽可能小的影响到其他情况。</p><hr><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;hr&gt;
&lt;p&gt;-改一款手机的bug应该考虑到一整个系列的手机类型。尤其是oem针对手机系统做适配，eg：全面屏手机顶部被遮盖，顶部挤压等应该向厂商咨询一整个系列的全面屏手机型号，而不是只针对一款手机做适配，解决问题要彻底，考虑问题要更全面。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;-
      
    
    </summary>
    
      <category term="心得" scheme="http://yoursite.com/categories/%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="random" scheme="http://yoursite.com/tags/random/"/>
    
  </entry>
  
</feed>
